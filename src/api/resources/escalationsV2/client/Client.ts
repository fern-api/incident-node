// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
import { type NormalizedClientOptions, normalizeClientOptions } from "../../../../BaseClient.js";
import { mergeHeaders } from "../../../../core/headers.js";
import * as core from "../../../../core/index.js";
import { toJson } from "../../../../core/json.js";
import * as environments from "../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../errors/index.js";
import type * as FernApi from "../../../index.js";

export declare namespace EscalationsV2Client {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

/**
 * Create and manage escalation paths, and create, list and filter escalations.
 *
 * With incident.io On-call you can create escalation paths that describe how a page should
 * be escalated to people and schedules.
 */
export class EscalationsV2Client {
    protected readonly _options: NormalizedClientOptions<EscalationsV2Client.Options>;

    constructor(options: EscalationsV2Client.Options = {}) {
        this._options = normalizeClientOptions(options);
    }

    /**
     * Create an escalation path.
     *
     * An escalation path is a series of steps that describe how a page should be escalated,
     * represented as graph, supporting conditional branches based on alert priority and working
     * intervals.
     *
     * We recommend you create escalation paths in the incident.io dashboard where our path
     * builder makes it easy to use conditions and visualise the path.
     *
     * @param {FernApi.EscalationsCreatePathPayloadV2} request
     * @param {EscalationsV2Client.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.escalationsV2.createpath({
     *         name: "Urgent Support",
     *         path: [{
     *                 id: "01FCNDV6P870EA6S7TK1DSYDG0",
     *                 if_else: {
     *                     conditions: [{
     *                             operation: "one_of",
     *                             param_bindings: [{
     *                                     array_value: [{
     *                                             literal: "SEV123",
     *                                             reference: "incident.severity"
     *                                         }],
     *                                     value: {
     *                                         literal: "SEV123",
     *                                         reference: "incident.severity"
     *                                     }
     *                                 }],
     *                             subject: "incident.severity"
     *                         }],
     *                     else_path: [],
     *                     then_path: []
     *                 },
     *                 level: {
     *                     ack_mode: "all",
     *                     round_robin_config: {
     *                         enabled: false,
     *                         rotate_after_seconds: 120
     *                     },
     *                     targets: [{
     *                             id: "lawrencejones",
     *                             schedule_mode: "currently_on_call",
     *                             type: "schedule",
     *                             urgency: "high"
     *                         }],
     *                     time_to_ack_interval_condition: "active",
     *                     time_to_ack_seconds: 1800,
     *                     time_to_ack_weekday_interval_config_id: "01FCNDV6P870EA6S7TK1DSYDG0"
     *                 },
     *                 notify_channel: {
     *                     targets: [{
     *                             id: "lawrencejones",
     *                             schedule_mode: "currently_on_call",
     *                             type: "schedule",
     *                             urgency: "high"
     *                         }],
     *                     time_to_ack_interval_condition: "active",
     *                     time_to_ack_seconds: 1800,
     *                     time_to_ack_weekday_interval_config_id: "01FCNDV6P870EA6S7TK1DSYDG0"
     *                 },
     *                 repeat: {
     *                     repeat_times: 3,
     *                     to_node: "01FCNDV6P870EA6S7TK1DSYDG0"
     *                 },
     *                 type: "if_else"
     *             }],
     *         team_ids: ["01JPQA75EPNEES4479P16P4XAB"],
     *         working_hours: [{
     *                 id: "abc123",
     *                 name: "abc123",
     *                 timezone: "abc123",
     *                 weekday_intervals: [{
     *                         end_time: "17:00",
     *                         start_time: "09:00",
     *                         weekday: "monday"
     *                     }]
     *             }]
     *     })
     */
    public createpath(
        request: FernApi.EscalationsCreatePathPayloadV2,
        requestOptions?: EscalationsV2Client.RequestOptions,
    ): core.HttpResponsePromise<FernApi.EscalationsCreatePathResultV2> {
        return core.HttpResponsePromise.fromPromise(this.__createpath(request, requestOptions));
    }

    private async __createpath(
        request: FernApi.EscalationsCreatePathPayloadV2,
        requestOptions?: EscalationsV2Client.RequestOptions,
    ): Promise<core.WithRawResponse<FernApi.EscalationsCreatePathResultV2>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.FernApiEnvironment.Default,
                "v2/escalation_paths",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as FernApi.EscalationsCreatePathResultV2,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.FernApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v2/escalation_paths");
    }

    /**
     * Show an escalation path.
     *
     * We recommend you create escalation paths in the incident.io dashboard where our path
     * builder makes it easy to use conditions and visualise the path.
     *
     * @param {FernApi.EscalationsV2ShowPathRequest} request
     * @param {EscalationsV2Client.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.escalationsV2.showpath({
     *         id: "01FCNDV6P870EA6S7TK1DSYDG0"
     *     })
     */
    public showpath(
        request: FernApi.EscalationsV2ShowPathRequest,
        requestOptions?: EscalationsV2Client.RequestOptions,
    ): core.HttpResponsePromise<FernApi.EscalationsShowPathResultV2> {
        return core.HttpResponsePromise.fromPromise(this.__showpath(request, requestOptions));
    }

    private async __showpath(
        request: FernApi.EscalationsV2ShowPathRequest,
        requestOptions?: EscalationsV2Client.RequestOptions,
    ): Promise<core.WithRawResponse<FernApi.EscalationsShowPathResultV2>> {
        const { id } = request;
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.FernApiEnvironment.Default,
                `v2/escalation_paths/${core.url.encodePathParam(id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as FernApi.EscalationsShowPathResultV2, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.FernApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v2/escalation_paths/{id}");
    }

    /**
     * Updates an escalation path.
     *
     * We recommend you create escalation paths in the incident.io dashboard where our path
     * builder makes it easy to use conditions and visualise the path.
     *
     * @param {FernApi.EscalationsUpdatePathPayloadV2} request
     * @param {EscalationsV2Client.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.escalationsV2.updatepath({
     *         id: "01FCNDV6P870EA6S7TK1DSYDG0",
     *         name: "Urgent Support",
     *         path: [{
     *                 id: "01FCNDV6P870EA6S7TK1DSYDG0",
     *                 if_else: {
     *                     conditions: [{
     *                             operation: "one_of",
     *                             param_bindings: [{
     *                                     array_value: [{
     *                                             literal: "SEV123",
     *                                             reference: "incident.severity"
     *                                         }],
     *                                     value: {
     *                                         literal: "SEV123",
     *                                         reference: "incident.severity"
     *                                     }
     *                                 }],
     *                             subject: "incident.severity"
     *                         }],
     *                     else_path: [],
     *                     then_path: []
     *                 },
     *                 level: {
     *                     ack_mode: "all",
     *                     round_robin_config: {
     *                         enabled: false,
     *                         rotate_after_seconds: 120
     *                     },
     *                     targets: [{
     *                             id: "lawrencejones",
     *                             schedule_mode: "currently_on_call",
     *                             type: "schedule",
     *                             urgency: "high"
     *                         }],
     *                     time_to_ack_interval_condition: "active",
     *                     time_to_ack_seconds: 1800,
     *                     time_to_ack_weekday_interval_config_id: "01FCNDV6P870EA6S7TK1DSYDG0"
     *                 },
     *                 notify_channel: {
     *                     targets: [{
     *                             id: "lawrencejones",
     *                             schedule_mode: "currently_on_call",
     *                             type: "schedule",
     *                             urgency: "high"
     *                         }],
     *                     time_to_ack_interval_condition: "active",
     *                     time_to_ack_seconds: 1800,
     *                     time_to_ack_weekday_interval_config_id: "01FCNDV6P870EA6S7TK1DSYDG0"
     *                 },
     *                 repeat: {
     *                     repeat_times: 3,
     *                     to_node: "01FCNDV6P870EA6S7TK1DSYDG0"
     *                 },
     *                 type: "if_else"
     *             }],
     *         team_ids: ["01JPQA75EPNEES4479P16P4XAB"],
     *         working_hours: [{
     *                 id: "abc123",
     *                 name: "abc123",
     *                 timezone: "abc123",
     *                 weekday_intervals: [{
     *                         end_time: "17:00",
     *                         start_time: "09:00",
     *                         weekday: "monday"
     *                     }]
     *             }]
     *     })
     */
    public updatepath(
        request: FernApi.EscalationsUpdatePathPayloadV2,
        requestOptions?: EscalationsV2Client.RequestOptions,
    ): core.HttpResponsePromise<FernApi.EscalationsUpdatePathResultV2> {
        return core.HttpResponsePromise.fromPromise(this.__updatepath(request, requestOptions));
    }

    private async __updatepath(
        request: FernApi.EscalationsUpdatePathPayloadV2,
        requestOptions?: EscalationsV2Client.RequestOptions,
    ): Promise<core.WithRawResponse<FernApi.EscalationsUpdatePathResultV2>> {
        const { id, ..._body } = request;
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.FernApiEnvironment.Default,
                `v2/escalation_paths/${core.url.encodePathParam(id)}`,
            ),
            method: "PUT",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: _body,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as FernApi.EscalationsUpdatePathResultV2,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.FernApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/v2/escalation_paths/{id}");
    }

    /**
     * Archives an escalation path.
     *
     * We recommend you create escalation paths in the incident.io dashboard where our path
     * builder makes it easy to use conditions and visualise the path.
     *
     * @param {FernApi.EscalationsV2DestroyPathRequest} request
     * @param {EscalationsV2Client.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.escalationsV2.destroypath({
     *         id: "01FCNDV6P870EA6S7TK1DSYDG0"
     *     })
     */
    public destroypath(
        request: FernApi.EscalationsV2DestroyPathRequest,
        requestOptions?: EscalationsV2Client.RequestOptions,
    ): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__destroypath(request, requestOptions));
    }

    private async __destroypath(
        request: FernApi.EscalationsV2DestroyPathRequest,
        requestOptions?: EscalationsV2Client.RequestOptions,
    ): Promise<core.WithRawResponse<void>> {
        const { id } = request;
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.FernApiEnvironment.Default,
                `v2/escalation_paths/${core.url.encodePathParam(id)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.FernApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/v2/escalation_paths/{id}");
    }

    /**
     * List all escalations for your account.
     *
     * This endpoint supports a number of filters, which can help find escalations matching certain
     * criteria.
     *
     * Note that:
     * - Filters may be used together, and the result will be escalations that match all filters.
     * - All query parameters must be URI encoded.
     *
     * To use this API, you will need an API key with the "View data" or "Create and manage on-call resources" permission.
     *
     * ### By escalation_path
     *
     * Find all escalations that escalated to escalation path with id=ABC:
     *
     * 		curl --get 'https://api.incident.io/v2/escalations' \
     * 			--data 'escalation_path[one_of]=ABC'
     *
     * ### By status
     *
     * Find all escalations with a current status of "triggered":
     *
     * 		curl --get 'https://api.incident.io/v2/escalations' \
     * 			--data 'status[one_of]=triggered'
     *
     * Possible values are "pending", "triggered", "acked", "resolved", "expired" and "cancelled".
     * Escalations are in "pending" when they are in a grace period when the related alert has
     * been grouped in an incident.
     *
     * ### By alert
     *
     * Find all escalations that were created by alert with id=ABC:
     *
     * 		curl --get 'https://api.incident.io/v2/escalations' \
     * 			--data 'alert[one_of]=ABC'
     *
     * ### By created_at and updated_at
     * Find all escalations that follow specified date parameters for created_at and updated_at fields.
     * Possible values are "gte" (greater than or equal to), "lte" (less than or equal to), and
     * "date_range" (between two dates).
     * For example, to find all escalations updated after 2025-01-01:
     *
     * 		curl --get 'https://api.incident.io/v2/escalations' \
     * 			--data 'updated_at[gte]=2025-01-01'
     *
     * To find all escalations created between 2025-01-01 and 2025-01-31:
     *
     * 		curl --get 'https://api.incident.io/v2/escalations' \
     *             --data 'created_at[date_range]=2025-01-01~2025-01-31'
     *
     * @param {FernApi.EscalationsV2ListRequest} request
     * @param {EscalationsV2Client.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.escalationsV2.list({
     *         page_size: 25,
     *         after: "01FDAG4SAP5TYPT98WGR2N7W91"
     *     })
     */
    public list(
        request: FernApi.EscalationsV2ListRequest = {},
        requestOptions?: EscalationsV2Client.RequestOptions,
    ): core.HttpResponsePromise<FernApi.EscalationsListResultV2> {
        return core.HttpResponsePromise.fromPromise(this.__list(request, requestOptions));
    }

    private async __list(
        request: FernApi.EscalationsV2ListRequest = {},
        requestOptions?: EscalationsV2Client.RequestOptions,
    ): Promise<core.WithRawResponse<FernApi.EscalationsListResultV2>> {
        const {
            page_size: pageSize,
            after,
            escalation_path: escalationPath,
            status,
            alert,
            created_at: createdAt,
            updated_at: updatedAt,
            idempotency_key: idempotencyKey,
        } = request;
        const _queryParams: Record<string, unknown> = {
            page_size: pageSize,
            after,
            escalation_path: escalationPath != null ? toJson(escalationPath) : undefined,
            status: status != null ? toJson(status) : undefined,
            alert: alert != null ? toJson(alert) : undefined,
            created_at: createdAt != null ? toJson(createdAt) : undefined,
            updated_at: updatedAt != null ? toJson(updatedAt) : undefined,
            idempotency_key: idempotencyKey != null ? toJson(idempotencyKey) : undefined,
        };
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.FernApiEnvironment.Default,
                "v2/escalations",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as FernApi.EscalationsListResultV2, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.FernApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v2/escalations");
    }

    /**
     * Create an escalation.
     *
     * An escalation pages people, either according to an escalation path, or directly to
     * specific users. You must provide either an escalation_path_id OR user_ids, but not both.
     *
     * When escalating via an escalation path, the escalation will follow the configured path
     * with its levels and timeouts, using your default [alert
     * priority](https://app.incident.io/~/settings/alerts/configuration/priorities).
     *
     * When escalating directly to users, they will receive a high-urgency
     * notification, based on their notification rules.
     *
     * This endpoint is rate-limited to 60 requests per minute, since it is intended for
     * interactive use cases (for example someone clicking a "escalate to team" button
     * in your internal developer platform). To escalate based on automated alerts, we
     * recommend sending events to an alert source instead.
     *
     * @param {FernApi.EscalationsCreatePayloadV2} request
     * @param {EscalationsV2Client.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.escalationsV2.create({
     *         description: "Database CPU has been above 90% for 5 minutes",
     *         escalation_path_id: "01H0J1EXE7AXZ2C93K61WBPYEH",
     *         idempotency_key: "2024-01-15-abc123",
     *         title: "Production database experiencing high CPU",
     *         user_ids: ["01H0J1EXE7AXZ2C93K61WBPYEH", "01H0J1EXE7AXZ2C93K61WBPYEI"]
     *     })
     */
    public create(
        request: FernApi.EscalationsCreatePayloadV2,
        requestOptions?: EscalationsV2Client.RequestOptions,
    ): core.HttpResponsePromise<FernApi.EscalationsCreateResultV2> {
        return core.HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
    }

    private async __create(
        request: FernApi.EscalationsCreatePayloadV2,
        requestOptions?: EscalationsV2Client.RequestOptions,
    ): Promise<core.WithRawResponse<FernApi.EscalationsCreateResultV2>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.FernApiEnvironment.Default,
                "v2/escalations",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as FernApi.EscalationsCreateResultV2, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.FernApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v2/escalations");
    }

    /**
     * Show a specific escalation.
     *
     * @param {FernApi.EscalationsV2ShowRequest} request
     * @param {EscalationsV2Client.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.escalationsV2.show({
     *         id: "01G0J1EXE7AXZ2C93K61WBPYEH"
     *     })
     */
    public show(
        request: FernApi.EscalationsV2ShowRequest,
        requestOptions?: EscalationsV2Client.RequestOptions,
    ): core.HttpResponsePromise<FernApi.EscalationsShowResultV2> {
        return core.HttpResponsePromise.fromPromise(this.__show(request, requestOptions));
    }

    private async __show(
        request: FernApi.EscalationsV2ShowRequest,
        requestOptions?: EscalationsV2Client.RequestOptions,
    ): Promise<core.WithRawResponse<FernApi.EscalationsShowResultV2>> {
        const { id } = request;
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.FernApiEnvironment.Default,
                `v2/escalations/${core.url.encodePathParam(id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as FernApi.EscalationsShowResultV2, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.FernApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v2/escalations/{id}");
    }
}
