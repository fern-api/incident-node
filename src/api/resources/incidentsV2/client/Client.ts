// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
import { type NormalizedClientOptions, normalizeClientOptions } from "../../../../BaseClient.js";
import { mergeHeaders } from "../../../../core/headers.js";
import * as core from "../../../../core/index.js";
import { toJson } from "../../../../core/json.js";
import * as environments from "../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../errors/index.js";
import type * as FernApi from "../../../index.js";

export declare namespace IncidentsV2Client {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

/**
 * Create and read incidents.
 *
 * Incidents are a core resource, on which many other resources (actions, etc) are created.
 *
 * Care should be taken around these endpoints, as automation that creates duplicate
 * incidents can be distracting, and impact reporting.
 */
export class IncidentsV2Client {
    protected readonly _options: NormalizedClientOptions<IncidentsV2Client.Options>;

    constructor(options: IncidentsV2Client.Options = {}) {
        this._options = normalizeClientOptions(options);
    }

    /**
     * List all incidents for an organisation.
     *
     * This endpoint supports a number of filters, which can help find incidents matching certain
     * criteria.
     *
     * Filters are provided as query parameters, but due to the dynamic nature of what you can
     * query by (different accounts have different custom fields, statuses, etc) they are more
     * complex than most.
     *
     * The maximum page size that can be requested is 250.
     *
     * To help, here are some exemplar curl requests with a human description of what they search
     * for.
     *
     * Note that:
     * - Filters may be combined using the filter_mode parameter: 'all' (default) requires all filters
     * to match (AND logic), while 'any' requires at least one filter to match (OR logic).
     * - IDs are normally in UUID format, but have been replaced with shorter strings to improve
     * readability.
     * - All query parameters must be URI encoded.
     *
     * ### By status
     *
     * With status of id=ABC, find all incidents that are set to that status:
     *
     * 		curl --get 'https://api.incident.io/v2/incidents' \
     * 			--data 'status[one_of]=ABC'
     *
     * Or all incidents that are not set to status with id=ABC:
     *
     * 		curl --get 'https://api.incident.io/v2/incidents' \
     * 			--data 'status[not_in]=ABC'
     *
     * ### By created_at or updated_at
     *
     * Find all incidents that follow specified date parameters for created_at and updated_at fields.
     * Possible values are "gte" (greater than or equal to), "lte" (less than or equal to), and
     * "date_range" (between two dates). The following example finds all incidents created before
     * or on 2021-01-02T00:00:00Z:
     *
     * 		curl --get 'https://api.incident.io/v2/incidents' \
     * 			--data 'created_at[lte]=2021-01-02'
     *
     * To find incidents created within a specific date range, use the date_range option with
     * tilde-separated dates:
     *
     * 		curl --get 'https://api.incident.io/v2/incidents' \
     * 			--data 'created_at[date_range]=2024-12-02~2024-12-08'
     *
     * ### By status category
     *
     * Find all incidents that are in a status category. Possible values are "triage",
     * "declined", "merged", "canceled", "live", "learning" and "closed":
     *
     * 		curl --get 'https://api.incident.io/v2/incidents' \
     * 			--data 'status_category[one_of]=live'
     *
     * Or all incidents that are not in a status category:
     *
     * 		curl --get 'https://api.incident.io/v2/incidents' \
     * 			--data 'status_category[not_in]=live'
     *
     *
     * ### By severity
     *
     * With severity of id=ABC, find all incidents that are set to that severity:
     *
     * 		curl --get 'https://api.incident.io/v2/incidents' \
     * 			--data 'severity[one_of]=ABC'
     *
     * Or all incidents where severity rank is greater-than-or-equal-to the rank of severity
     * id=ABC:
     *
     * 		curl --get 'https://api.incident.io/v2/incidents' \
     * 			--data 'severity[gte]=ABC'
     *
     * Or all incidents where severity rank is less-than-or-equal-to the rank of severity id=ABC:
     *
     * 		curl --get 'https://api.incident.io/v2/incidents' \
     * 			--data 'severity[lte]=ABC'
     *
     * ### By incident type
     *
     * With incident type of id=ABC, find all incidents that are of that type:
     *
     * 		curl --get 'https://api.incident.io/v2/incidents' \
     * 			--data 'incident_type[one_of]=ABC'
     *
     * Or all incidents not of that type:
     *
     * 		curl --get 'https://api.incident.io/v2/incidents' \
     * 			--data 'incident_type[not_in]=ABC'
     *
     * ### By incident mode
     *
     * By default, we return standard and retrospective incidents. This means that test and
     * tutorial incidents are filtered out. To override this behaviour, you can use the
     * mode filter to specify which modes you want to get.
     *
     * To find incidents of all modes:
     *
     * 		curl --get 'https://api.incident.io/v2/incidents' \
     * 			--data 'mode[one_of]=standard&mode[one_of]=retrospective&mode[one_of]=test&mode[one_of]=tutorial'
     *
     * To find just test incidents:
     *
     * 		curl --get 'https://api.incident.io/v2/incidents' \
     * 			--data 'mode[one_of]=test'
     *
     *
     * ### By incident role
     *
     * Roles and custom fields have another nested layer in the query parameter, to account for
     * operations against any of the roles or custom fields created in the account.
     *
     * With incident role id=ABC, find all incidents where that role is unset:
     *
     * 		curl --get 'https://api.incident.io/v2/incidents' \
     * 			--data 'incident_role[ABC][is_set]=true'
     *
     * Or where the role has been set:
     *
     * 		curl --get 'https://api.incident.io/v2/incidents' \
     * 			--data 'incident_role[ABC][is_set]=false'
     *
     * ### By option custom fields
     *
     * With an option custom field id=ABC, all incidents that have field ABC set to the custom
     * field option of id=XYZ:
     *
     * 		curl \
     * 			--get 'https://api.incident.io/v2/incidents' \
     * 			--data 'custom_field[ABC][one_of]=XYZ'
     *
     * Or all incidents that do not have custom field id=ABC set to option id=XYZ:
     *
     * 		curl \
     * 			--get 'https://api.incident.io/v2/incidents' \
     * 			--data 'custom_field[ABC][not_in]=XYZ'
     *
     * @param {FernApi.IncidentsV2ListRequest} request
     * @param {IncidentsV2Client.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.incidentsV2.list({
     *         page_size: 25,
     *         after: "01FDAG4SAP5TYPT98WGR2N7W91"
     *     })
     */
    public list(
        request: FernApi.IncidentsV2ListRequest = {},
        requestOptions?: IncidentsV2Client.RequestOptions,
    ): core.HttpResponsePromise<FernApi.IncidentsListResultV2> {
        return core.HttpResponsePromise.fromPromise(this.__list(request, requestOptions));
    }

    private async __list(
        request: FernApi.IncidentsV2ListRequest = {},
        requestOptions?: IncidentsV2Client.RequestOptions,
    ): Promise<core.WithRawResponse<FernApi.IncidentsListResultV2>> {
        const {
            page_size: pageSize,
            after,
            filter_mode: filterMode,
            status,
            status_category: statusCategory,
            created_at: createdAt,
            updated_at: updatedAt,
            severity,
            incident_type: incidentType,
            incident_role: incidentRole,
            custom_field: customField,
            mode,
        } = request;
        const _queryParams: Record<string, unknown> = {
            page_size: pageSize,
            after,
            filter_mode: filterMode != null ? filterMode : undefined,
            status: status != null ? toJson(status) : undefined,
            status_category: statusCategory != null ? toJson(statusCategory) : undefined,
            created_at: createdAt != null ? toJson(createdAt) : undefined,
            updated_at: updatedAt != null ? toJson(updatedAt) : undefined,
            severity: severity != null ? toJson(severity) : undefined,
            incident_type: incidentType != null ? toJson(incidentType) : undefined,
            incident_role: incidentRole != null ? toJson(incidentRole) : undefined,
            custom_field: customField != null ? toJson(customField) : undefined,
            mode: mode != null ? toJson(mode) : undefined,
        };
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.FernApiEnvironment.Default,
                "v2/incidents",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as FernApi.IncidentsListResultV2, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.FernApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v2/incidents");
    }

    /**
     * Create a new incident.
     *
     * Note that if the incident mode is set to "retrospective" then the new incident
     * will not be announced in Slack.
     *
     * @param {FernApi.IncidentsCreatePayloadV2} request
     * @param {IncidentsV2Client.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.incidentsV2.create({
     *         custom_field_entries: [{
     *                 custom_field_id: "01FCNDV6P870EA6S7TK1DSYDG0",
     *                 values: [{
     *                         id: "01FCNDV6P870EA6S7TK1DSYDG0",
     *                         value_catalog_entry_id: "01FCNDV6P870EA6S7TK1DSYDG0",
     *                         value_link: "https://google.com/",
     *                         value_numeric: "123.456",
     *                         value_option_id: "01FCNDV6P870EA6S7TK1DSYDG0",
     *                         value_text: "This is my text field, I hope you like it",
     *                         value_timestamp: ""
     *                     }]
     *             }],
     *         idempotency_key: "alert-uuid",
     *         incident_role_assignments: [{
     *                 assignee: {
     *                     email: "bob@example.com",
     *                     id: "01G0J1EXE7AXZ2C93K61WBPYEH",
     *                     slack_user_id: "USER123"
     *                 },
     *                 incident_role_id: "01FH5TZRWMNAFB0DZ23FD1TV96"
     *             }],
     *         incident_status_id: "01G0J1EXE7AXZ2C93K61WBPYEH",
     *         incident_timestamp_values: [{
     *                 incident_timestamp_id: "01FCNDV6P870EA6S7TK1DSYD5H",
     *                 value: "2021-08-17T13:28:57Z"
     *             }],
     *         incident_type_id: "01FH5TZRWMNAFB0DZ23FD1TV96",
     *         mode: "standard",
     *         name: "Our database is sad",
     *         retrospective_incident_options: {
     *             external_id: 123,
     *             postmortem_document_url: "https://docs.google.com/my_doc_id",
     *             slack_channel_id: "abc123"
     *         },
     *         severity_id: "01FH5TZRWMNAFB0DZ23FD1TV96",
     *         slack_channel_name_override: "inc-123-database-down",
     *         slack_team_id: "T02A1FSLE8J",
     *         summary: "Our database is really really sad, and we don't know why yet.",
     *         visibility: "public"
     *     })
     */
    public create(
        request: FernApi.IncidentsCreatePayloadV2,
        requestOptions?: IncidentsV2Client.RequestOptions,
    ): core.HttpResponsePromise<FernApi.IncidentsCreateResultV2> {
        return core.HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
    }

    private async __create(
        request: FernApi.IncidentsCreatePayloadV2,
        requestOptions?: IncidentsV2Client.RequestOptions,
    ): Promise<core.WithRawResponse<FernApi.IncidentsCreateResultV2>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.FernApiEnvironment.Default,
                "v2/incidents",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as FernApi.IncidentsCreateResultV2, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.FernApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v2/incidents");
    }

    /**
     * Get a single incident.
     *
     * The ID supplied can be either the incident's full ID, or the numeric part of its
     * reference. For example, to get INC-123, you could use either its full ID or:
     *
     * 		curl \
     * 			--get 'https://api.incident.io/v2/incidents/123
     *
     * @param {FernApi.IncidentsV2ShowRequest} request
     * @param {IncidentsV2Client.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.incidentsV2.show({
     *         id: "01FDAG4SAP5TYPT98WGR2N7W91"
     *     })
     */
    public show(
        request: FernApi.IncidentsV2ShowRequest,
        requestOptions?: IncidentsV2Client.RequestOptions,
    ): core.HttpResponsePromise<FernApi.IncidentsShowResultV2> {
        return core.HttpResponsePromise.fromPromise(this.__show(request, requestOptions));
    }

    private async __show(
        request: FernApi.IncidentsV2ShowRequest,
        requestOptions?: IncidentsV2Client.RequestOptions,
    ): Promise<core.WithRawResponse<FernApi.IncidentsShowResultV2>> {
        const { id } = request;
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.FernApiEnvironment.Default,
                `v2/incidents/${core.url.encodePathParam(id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as FernApi.IncidentsShowResultV2, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.FernApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/v2/incidents/{id}");
    }

    /**
     * Edit an existing incident.
     *
     * This endpoint allows you to edit the properties of an existing incident: e.g. set the severity or update custom fields.
     *
     * When using this endpoint, only fields that are provided will be edited (omitted fields
     * will be ignored).
     *
     * @param {FernApi.IncidentsEditPayloadV2} request
     * @param {IncidentsV2Client.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.incidentsV2.edit({
     *         id: "01G18REBY9AYH6CMWCJ2CVCYCH",
     *         incident: {
     *             call_url: "https://zoom.us/foo",
     *             custom_field_entries: [{
     *                     custom_field_id: "01FCNDV6P870EA6S7TK1DSYDG0",
     *                     values: [{
     *                             id: "01FCNDV6P870EA6S7TK1DSYDG0",
     *                             value_catalog_entry_id: "01FCNDV6P870EA6S7TK1DSYDG0",
     *                             value_link: "https://google.com/",
     *                             value_numeric: "123.456",
     *                             value_option_id: "01FCNDV6P870EA6S7TK1DSYDG0",
     *                             value_text: "This is my text field, I hope you like it",
     *                             value_timestamp: ""
     *                         }]
     *                 }],
     *             incident_role_assignments: [{
     *                     assignee: {
     *                         email: "bob@example.com",
     *                         id: "01G0J1EXE7AXZ2C93K61WBPYEH",
     *                         slack_user_id: "USER123"
     *                     },
     *                     incident_role_id: "01FH5TZRWMNAFB0DZ23FD1TV96"
     *                 }],
     *             incident_status_id: "abc123",
     *             incident_timestamp_values: [{
     *                     incident_timestamp_id: "01FCNDV6P870EA6S7TK1DSYD5H",
     *                     value: "2021-08-17T13:28:57Z"
     *                 }],
     *             name: "Our database is sad",
     *             severity_id: "01G0J1EXE7AXZ2C93K61WBPYEH",
     *             slack_channel_name_override: "inc-123-database-down",
     *             summary: "Our database is really really sad, and we don't know why yet."
     *         },
     *         notify_incident_channel: true
     *     })
     */
    public edit(
        request: FernApi.IncidentsEditPayloadV2,
        requestOptions?: IncidentsV2Client.RequestOptions,
    ): core.HttpResponsePromise<FernApi.IncidentsEditResultV2> {
        return core.HttpResponsePromise.fromPromise(this.__edit(request, requestOptions));
    }

    private async __edit(
        request: FernApi.IncidentsEditPayloadV2,
        requestOptions?: IncidentsV2Client.RequestOptions,
    ): Promise<core.WithRawResponse<FernApi.IncidentsEditResultV2>> {
        const { id, ..._body } = request;
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.FernApiEnvironment.Default,
                `v2/incidents/${core.url.encodePathParam(id)}/actions/edit`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: _body,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as FernApi.IncidentsEditResultV2, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.FernApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v2/incidents/{id}/actions/edit",
        );
    }
}
